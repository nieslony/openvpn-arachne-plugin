
/*
 * This file was automatically generated by sdbus-c++-xml2cpp; DO NOT EDIT!
 */

#ifndef __sdbuscpp__firewalld_proxy_sdbus_2_FirewallD1_Proxy_h__proxy__H__
#define __sdbuscpp__firewalld_proxy_sdbus_2_FirewallD1_Proxy_h__proxy__H__

#include <sdbus-c++/sdbus-c++.h>
#include <string>
#include <tuple>

namespace org {
namespace fedoraproject {

class FirewallD1_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.fedoraproject.FirewallD1";

protected:
    FirewallD1_proxy(sdbus::IProxy& proxy)
        : m_proxy(proxy)
    {
    }

    FirewallD1_proxy(const FirewallD1_proxy&) = delete;
    FirewallD1_proxy& operator=(const FirewallD1_proxy&) = delete;
    FirewallD1_proxy(FirewallD1_proxy&&) = delete;
    FirewallD1_proxy& operator=(FirewallD1_proxy&&) = delete;

    ~FirewallD1_proxy() = default;

    void registerProxy()
    {
        m_proxy.uponSignal("Reloaded").onInterface(INTERFACE_NAME).call([this](){ this->onReloaded(); });
        m_proxy.uponSignal("PanicModeEnabled").onInterface(INTERFACE_NAME).call([this](){ this->onPanicModeEnabled(); });
        m_proxy.uponSignal("PanicModeDisabled").onInterface(INTERFACE_NAME).call([this](){ this->onPanicModeDisabled(); });
        m_proxy.uponSignal("LogDeniedChanged").onInterface(INTERFACE_NAME).call([this](const std::string& value){ this->onLogDeniedChanged(value); });
        m_proxy.uponSignal("AutomaticHelpersChanged").onInterface(INTERFACE_NAME).call([this](const std::string& value){ this->onAutomaticHelpersChanged(value); });
        m_proxy.uponSignal("DefaultZoneChanged").onInterface(INTERFACE_NAME).call([this](const std::string& zone){ this->onDefaultZoneChanged(zone); });
    }

    virtual void onReloaded() = 0;
    virtual void onPanicModeEnabled() = 0;
    virtual void onPanicModeDisabled() = 0;
    virtual void onLogDeniedChanged(const std::string& value) = 0;
    virtual void onAutomaticHelpersChanged(const std::string& value) = 0;
    virtual void onDefaultZoneChanged(const std::string& zone) = 0;

public:
    void reload()
    {
        m_proxy.callMethod("reload").onInterface(INTERFACE_NAME);
    }

    void completeReload()
    {
        m_proxy.callMethod("completeReload").onInterface(INTERFACE_NAME);
    }

    void resetToDefaults()
    {
        m_proxy.callMethod("resetToDefaults").onInterface(INTERFACE_NAME);
    }

    void checkPermanentConfig()
    {
        m_proxy.callMethod("checkPermanentConfig").onInterface(INTERFACE_NAME);
    }

    void runtimeToPermanent()
    {
        m_proxy.callMethod("runtimeToPermanent").onInterface(INTERFACE_NAME);
    }

    void enablePanicMode()
    {
        m_proxy.callMethod("enablePanicMode").onInterface(INTERFACE_NAME);
    }

    void disablePanicMode()
    {
        m_proxy.callMethod("disablePanicMode").onInterface(INTERFACE_NAME);
    }

    bool queryPanicMode()
    {
        bool result;
        m_proxy.callMethod("queryPanicMode").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    sdbus::Struct<std::string, std::string, std::string, bool, std::string, std::vector<std::string>, std::vector<sdbus::Struct<std::string, std::string>>, std::vector<std::string>, bool, std::vector<sdbus::Struct<std::string, std::string, std::string, std::string>>, std::vector<std::string>, std::vector<std::string>, std::vector<std::string>, std::vector<std::string>, std::vector<sdbus::Struct<std::string, std::string>>, bool> getZoneSettings(const std::string& zone)
    {
        sdbus::Struct<std::string, std::string, std::string, bool, std::string, std::vector<std::string>, std::vector<sdbus::Struct<std::string, std::string>>, std::vector<std::string>, bool, std::vector<sdbus::Struct<std::string, std::string, std::string, std::string>>, std::vector<std::string>, std::vector<std::string>, std::vector<std::string>, std::vector<std::string>, std::vector<sdbus::Struct<std::string, std::string>>, bool> result;
        m_proxy.callMethod("getZoneSettings").onInterface(INTERFACE_NAME).withArguments(zone).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> listServices()
    {
        std::vector<std::string> result;
        m_proxy.callMethod("listServices").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    sdbus::Struct<std::string, std::string, std::string, std::vector<sdbus::Struct<std::string, std::string>>, std::vector<std::string>, std::map<std::string, std::string>, std::vector<std::string>, std::vector<sdbus::Struct<std::string, std::string>>> getServiceSettings(const std::string& service)
    {
        sdbus::Struct<std::string, std::string, std::string, std::vector<sdbus::Struct<std::string, std::string>>, std::vector<std::string>, std::map<std::string, std::string>, std::vector<std::string>, std::vector<sdbus::Struct<std::string, std::string>>> result;
        m_proxy.callMethod("getServiceSettings").onInterface(INTERFACE_NAME).withArguments(service).storeResultsTo(result);
        return result;
    }

    std::map<std::string, sdbus::Variant> getServiceSettings2(const std::string& service)
    {
        std::map<std::string, sdbus::Variant> result;
        m_proxy.callMethod("getServiceSettings2").onInterface(INTERFACE_NAME).withArguments(service).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> listIcmpTypes()
    {
        std::vector<std::string> result;
        m_proxy.callMethod("listIcmpTypes").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    sdbus::Struct<std::string, std::string, std::string, std::vector<std::string>> getIcmpTypeSettings(const std::string& icmptype)
    {
        sdbus::Struct<std::string, std::string, std::string, std::vector<std::string>> result;
        m_proxy.callMethod("getIcmpTypeSettings").onInterface(INTERFACE_NAME).withArguments(icmptype).storeResultsTo(result);
        return result;
    }

    std::string getLogDenied()
    {
        std::string result;
        m_proxy.callMethod("getLogDenied").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    void setLogDenied(const std::string& value)
    {
        m_proxy.callMethod("setLogDenied").onInterface(INTERFACE_NAME).withArguments(value);
    }

    std::string getAutomaticHelpers()
    {
        std::string result;
        m_proxy.callMethod("getAutomaticHelpers").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    void setAutomaticHelpers(const std::string& value)
    {
        m_proxy.callMethod("setAutomaticHelpers").onInterface(INTERFACE_NAME).withArguments(value);
    }

    std::string getDefaultZone()
    {
        std::string result;
        m_proxy.callMethod("getDefaultZone").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    void setDefaultZone(const std::string& zone)
    {
        m_proxy.callMethod("setDefaultZone").onInterface(INTERFACE_NAME).withArguments(zone);
    }

    void authorizeAll()
    {
        m_proxy.callMethod("authorizeAll").onInterface(INTERFACE_NAME);
    }

    std::vector<std::string> getHelpers()
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getHelpers").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    sdbus::Struct<std::string, std::string, std::string, std::string, std::string, std::vector<sdbus::Struct<std::string, std::string>>> getHelperSettings(const std::string& helper)
    {
        sdbus::Struct<std::string, std::string, std::string, std::string, std::string, std::vector<sdbus::Struct<std::string, std::string>>> result;
        m_proxy.callMethod("getHelperSettings").onInterface(INTERFACE_NAME).withArguments(helper).storeResultsTo(result);
        return result;
    }

public:
    std::string version()
    {
        return m_proxy.getProperty("version").onInterface(INTERFACE_NAME).get<std::string>();
    }

    std::string interface_version()
    {
        return m_proxy.getProperty("interface_version").onInterface(INTERFACE_NAME).get<std::string>();
    }

    std::string state()
    {
        return m_proxy.getProperty("state").onInterface(INTERFACE_NAME).get<std::string>();
    }

    bool IPv4()
    {
        return m_proxy.getProperty("IPv4").onInterface(INTERFACE_NAME).get<bool>();
    }

    bool IPv6()
    {
        return m_proxy.getProperty("IPv6").onInterface(INTERFACE_NAME).get<bool>();
    }

    bool IPv6_rpfilter()
    {
        return m_proxy.getProperty("IPv6_rpfilter").onInterface(INTERFACE_NAME).get<bool>();
    }

    bool BRIDGE()
    {
        return m_proxy.getProperty("BRIDGE").onInterface(INTERFACE_NAME).get<bool>();
    }

    bool IPSet()
    {
        return m_proxy.getProperty("IPSet").onInterface(INTERFACE_NAME).get<bool>();
    }

    std::vector<std::string> IPSetTypes()
    {
        return m_proxy.getProperty("IPSetTypes").onInterface(INTERFACE_NAME).get<std::vector<std::string>>();
    }

    bool nf_conntrack_helper_setting()
    {
        return m_proxy.getProperty("nf_conntrack_helper_setting").onInterface(INTERFACE_NAME).get<bool>();
    }

    std::map<std::string, std::vector<std::string>> nf_conntrack_helpers()
    {
        return m_proxy.getProperty("nf_conntrack_helpers").onInterface(INTERFACE_NAME).get<std::map<std::string, std::vector<std::string>>>();
    }

    std::map<std::string, std::vector<std::string>> nf_nat_helpers()
    {
        return m_proxy.getProperty("nf_nat_helpers").onInterface(INTERFACE_NAME).get<std::map<std::string, std::vector<std::string>>>();
    }

    std::vector<std::string> IPv4ICMPTypes()
    {
        return m_proxy.getProperty("IPv4ICMPTypes").onInterface(INTERFACE_NAME).get<std::vector<std::string>>();
    }

    std::vector<std::string> IPv6ICMPTypes()
    {
        return m_proxy.getProperty("IPv6ICMPTypes").onInterface(INTERFACE_NAME).get<std::vector<std::string>>();
    }

private:
    sdbus::IProxy& m_proxy;
};

}} // namespaces

namespace org {
namespace fedoraproject {
namespace FirewallD1 {

class policies_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.fedoraproject.FirewallD1.policies";

protected:
    policies_proxy(sdbus::IProxy& proxy)
        : m_proxy(proxy)
    {
    }

    policies_proxy(const policies_proxy&) = delete;
    policies_proxy& operator=(const policies_proxy&) = delete;
    policies_proxy(policies_proxy&&) = delete;
    policies_proxy& operator=(policies_proxy&&) = delete;

    ~policies_proxy() = default;

    void registerProxy()
    {
        m_proxy.uponSignal("LockdownEnabled").onInterface(INTERFACE_NAME).call([this](){ this->onLockdownEnabled(); });
        m_proxy.uponSignal("LockdownDisabled").onInterface(INTERFACE_NAME).call([this](){ this->onLockdownDisabled(); });
        m_proxy.uponSignal("LockdownWhitelistCommandAdded").onInterface(INTERFACE_NAME).call([this](const std::string& command){ this->onLockdownWhitelistCommandAdded(command); });
        m_proxy.uponSignal("LockdownWhitelistCommandRemoved").onInterface(INTERFACE_NAME).call([this](const std::string& command){ this->onLockdownWhitelistCommandRemoved(command); });
        m_proxy.uponSignal("LockdownWhitelistUidAdded").onInterface(INTERFACE_NAME).call([this](const int32_t& uid){ this->onLockdownWhitelistUidAdded(uid); });
        m_proxy.uponSignal("LockdownWhitelistUidRemoved").onInterface(INTERFACE_NAME).call([this](const int32_t& uid){ this->onLockdownWhitelistUidRemoved(uid); });
        m_proxy.uponSignal("LockdownWhitelistUserAdded").onInterface(INTERFACE_NAME).call([this](const std::string& user){ this->onLockdownWhitelistUserAdded(user); });
        m_proxy.uponSignal("LockdownWhitelistUserRemoved").onInterface(INTERFACE_NAME).call([this](const std::string& user){ this->onLockdownWhitelistUserRemoved(user); });
        m_proxy.uponSignal("LockdownWhitelistContextAdded").onInterface(INTERFACE_NAME).call([this](const std::string& context){ this->onLockdownWhitelistContextAdded(context); });
        m_proxy.uponSignal("LockdownWhitelistContextRemoved").onInterface(INTERFACE_NAME).call([this](const std::string& context){ this->onLockdownWhitelistContextRemoved(context); });
    }

    virtual void onLockdownEnabled() = 0;
    virtual void onLockdownDisabled() = 0;
    virtual void onLockdownWhitelistCommandAdded(const std::string& command) = 0;
    virtual void onLockdownWhitelistCommandRemoved(const std::string& command) = 0;
    virtual void onLockdownWhitelistUidAdded(const int32_t& uid) = 0;
    virtual void onLockdownWhitelistUidRemoved(const int32_t& uid) = 0;
    virtual void onLockdownWhitelistUserAdded(const std::string& user) = 0;
    virtual void onLockdownWhitelistUserRemoved(const std::string& user) = 0;
    virtual void onLockdownWhitelistContextAdded(const std::string& context) = 0;
    virtual void onLockdownWhitelistContextRemoved(const std::string& context) = 0;

public:
    void enableLockdown()
    {
        m_proxy.callMethod("enableLockdown").onInterface(INTERFACE_NAME);
    }

    void disableLockdown()
    {
        m_proxy.callMethod("disableLockdown").onInterface(INTERFACE_NAME);
    }

    bool queryLockdown()
    {
        bool result;
        m_proxy.callMethod("queryLockdown").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    void addLockdownWhitelistCommand(const std::string& command)
    {
        m_proxy.callMethod("addLockdownWhitelistCommand").onInterface(INTERFACE_NAME).withArguments(command);
    }

    void removeLockdownWhitelistCommand(const std::string& command)
    {
        m_proxy.callMethod("removeLockdownWhitelistCommand").onInterface(INTERFACE_NAME).withArguments(command);
    }

    bool queryLockdownWhitelistCommand(const std::string& command)
    {
        bool result;
        m_proxy.callMethod("queryLockdownWhitelistCommand").onInterface(INTERFACE_NAME).withArguments(command).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getLockdownWhitelistCommands()
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getLockdownWhitelistCommands").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    void addLockdownWhitelistUid(const int32_t& uid)
    {
        m_proxy.callMethod("addLockdownWhitelistUid").onInterface(INTERFACE_NAME).withArguments(uid);
    }

    void removeLockdownWhitelistUid(const int32_t& uid)
    {
        m_proxy.callMethod("removeLockdownWhitelistUid").onInterface(INTERFACE_NAME).withArguments(uid);
    }

    bool queryLockdownWhitelistUid(const int32_t& uid)
    {
        bool result;
        m_proxy.callMethod("queryLockdownWhitelistUid").onInterface(INTERFACE_NAME).withArguments(uid).storeResultsTo(result);
        return result;
    }

    std::vector<int32_t> getLockdownWhitelistUids()
    {
        std::vector<int32_t> result;
        m_proxy.callMethod("getLockdownWhitelistUids").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    void addLockdownWhitelistUser(const std::string& user)
    {
        m_proxy.callMethod("addLockdownWhitelistUser").onInterface(INTERFACE_NAME).withArguments(user);
    }

    void removeLockdownWhitelistUser(const std::string& user)
    {
        m_proxy.callMethod("removeLockdownWhitelistUser").onInterface(INTERFACE_NAME).withArguments(user);
    }

    bool queryLockdownWhitelistUser(const std::string& user)
    {
        bool result;
        m_proxy.callMethod("queryLockdownWhitelistUser").onInterface(INTERFACE_NAME).withArguments(user).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getLockdownWhitelistUsers()
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getLockdownWhitelistUsers").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    void addLockdownWhitelistContext(const std::string& context)
    {
        m_proxy.callMethod("addLockdownWhitelistContext").onInterface(INTERFACE_NAME).withArguments(context);
    }

    void removeLockdownWhitelistContext(const std::string& context)
    {
        m_proxy.callMethod("removeLockdownWhitelistContext").onInterface(INTERFACE_NAME).withArguments(context);
    }

    bool queryLockdownWhitelistContext(const std::string& context)
    {
        bool result;
        m_proxy.callMethod("queryLockdownWhitelistContext").onInterface(INTERFACE_NAME).withArguments(context).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getLockdownWhitelistContexts()
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getLockdownWhitelistContexts").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

private:
    sdbus::IProxy& m_proxy;
};

}}} // namespaces

namespace org {
namespace fedoraproject {
namespace FirewallD1 {

class zone_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.fedoraproject.FirewallD1.zone";

protected:
    zone_proxy(sdbus::IProxy& proxy)
        : m_proxy(proxy)
    {
    }

    zone_proxy(const zone_proxy&) = delete;
    zone_proxy& operator=(const zone_proxy&) = delete;
    zone_proxy(zone_proxy&&) = delete;
    zone_proxy& operator=(zone_proxy&&) = delete;

    ~zone_proxy() = default;

    void registerProxy()
    {
        m_proxy.uponSignal("ZoneUpdated").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::map<std::string, sdbus::Variant>& settings){ this->onZoneUpdated(zone, settings); });
        m_proxy.uponSignal("InterfaceAdded").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& interface){ this->onInterfaceAdded(zone, interface); });
        m_proxy.uponSignal("ZoneChanged").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& interface){ this->onZoneChanged(zone, interface); });
        m_proxy.uponSignal("ZoneOfInterfaceChanged").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& interface){ this->onZoneOfInterfaceChanged(zone, interface); });
        m_proxy.uponSignal("InterfaceRemoved").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& interface){ this->onInterfaceRemoved(zone, interface); });
        m_proxy.uponSignal("SourceAdded").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& source){ this->onSourceAdded(zone, source); });
        m_proxy.uponSignal("ZoneOfSourceChanged").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& source){ this->onZoneOfSourceChanged(zone, source); });
        m_proxy.uponSignal("SourceRemoved").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& source){ this->onSourceRemoved(zone, source); });
        m_proxy.uponSignal("RichRuleAdded").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& rule, const int32_t& timeout){ this->onRichRuleAdded(zone, rule, timeout); });
        m_proxy.uponSignal("RichRuleRemoved").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& rule){ this->onRichRuleRemoved(zone, rule); });
        m_proxy.uponSignal("ServiceAdded").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& service, const int32_t& timeout){ this->onServiceAdded(zone, service, timeout); });
        m_proxy.uponSignal("ServiceRemoved").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& service){ this->onServiceRemoved(zone, service); });
        m_proxy.uponSignal("PortAdded").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& port, const std::string& protocol, const int32_t& timeout){ this->onPortAdded(zone, port, protocol, timeout); });
        m_proxy.uponSignal("PortRemoved").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& port, const std::string& protocol){ this->onPortRemoved(zone, port, protocol); });
        m_proxy.uponSignal("ProtocolAdded").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& protocol, const int32_t& timeout){ this->onProtocolAdded(zone, protocol, timeout); });
        m_proxy.uponSignal("ProtocolRemoved").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& protocol){ this->onProtocolRemoved(zone, protocol); });
        m_proxy.uponSignal("SourcePortAdded").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& port, const std::string& protocol, const int32_t& timeout){ this->onSourcePortAdded(zone, port, protocol, timeout); });
        m_proxy.uponSignal("SourcePortRemoved").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& port, const std::string& protocol){ this->onSourcePortRemoved(zone, port, protocol); });
        m_proxy.uponSignal("MasqueradeAdded").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const int32_t& timeout){ this->onMasqueradeAdded(zone, timeout); });
        m_proxy.uponSignal("MasqueradeRemoved").onInterface(INTERFACE_NAME).call([this](const std::string& zone){ this->onMasqueradeRemoved(zone); });
        m_proxy.uponSignal("ForwardPortAdded").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& port, const std::string& protocol, const std::string& toport, const std::string& toaddr, const int32_t& timeout){ this->onForwardPortAdded(zone, port, protocol, toport, toaddr, timeout); });
        m_proxy.uponSignal("ForwardPortRemoved").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& port, const std::string& protocol, const std::string& toport, const std::string& toaddr){ this->onForwardPortRemoved(zone, port, protocol, toport, toaddr); });
        m_proxy.uponSignal("IcmpBlockAdded").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& icmp, const int32_t& timeout){ this->onIcmpBlockAdded(zone, icmp, timeout); });
        m_proxy.uponSignal("IcmpBlockRemoved").onInterface(INTERFACE_NAME).call([this](const std::string& zone, const std::string& icmp){ this->onIcmpBlockRemoved(zone, icmp); });
        m_proxy.uponSignal("IcmpBlockInversionAdded").onInterface(INTERFACE_NAME).call([this](const std::string& zone){ this->onIcmpBlockInversionAdded(zone); });
        m_proxy.uponSignal("IcmpBlockInversionRemoved").onInterface(INTERFACE_NAME).call([this](const std::string& zone){ this->onIcmpBlockInversionRemoved(zone); });
    }

    virtual void onZoneUpdated(const std::string& zone, const std::map<std::string, sdbus::Variant>& settings) = 0;
    virtual void onInterfaceAdded(const std::string& zone, const std::string& interface) = 0;
    virtual void onZoneChanged(const std::string& zone, const std::string& interface) = 0;
    virtual void onZoneOfInterfaceChanged(const std::string& zone, const std::string& interface) = 0;
    virtual void onInterfaceRemoved(const std::string& zone, const std::string& interface) = 0;
    virtual void onSourceAdded(const std::string& zone, const std::string& source) = 0;
    virtual void onZoneOfSourceChanged(const std::string& zone, const std::string& source) = 0;
    virtual void onSourceRemoved(const std::string& zone, const std::string& source) = 0;
    virtual void onRichRuleAdded(const std::string& zone, const std::string& rule, const int32_t& timeout) = 0;
    virtual void onRichRuleRemoved(const std::string& zone, const std::string& rule) = 0;
    virtual void onServiceAdded(const std::string& zone, const std::string& service, const int32_t& timeout) = 0;
    virtual void onServiceRemoved(const std::string& zone, const std::string& service) = 0;
    virtual void onPortAdded(const std::string& zone, const std::string& port, const std::string& protocol, const int32_t& timeout) = 0;
    virtual void onPortRemoved(const std::string& zone, const std::string& port, const std::string& protocol) = 0;
    virtual void onProtocolAdded(const std::string& zone, const std::string& protocol, const int32_t& timeout) = 0;
    virtual void onProtocolRemoved(const std::string& zone, const std::string& protocol) = 0;
    virtual void onSourcePortAdded(const std::string& zone, const std::string& port, const std::string& protocol, const int32_t& timeout) = 0;
    virtual void onSourcePortRemoved(const std::string& zone, const std::string& port, const std::string& protocol) = 0;
    virtual void onMasqueradeAdded(const std::string& zone, const int32_t& timeout) = 0;
    virtual void onMasqueradeRemoved(const std::string& zone) = 0;
    virtual void onForwardPortAdded(const std::string& zone, const std::string& port, const std::string& protocol, const std::string& toport, const std::string& toaddr, const int32_t& timeout) = 0;
    virtual void onForwardPortRemoved(const std::string& zone, const std::string& port, const std::string& protocol, const std::string& toport, const std::string& toaddr) = 0;
    virtual void onIcmpBlockAdded(const std::string& zone, const std::string& icmp, const int32_t& timeout) = 0;
    virtual void onIcmpBlockRemoved(const std::string& zone, const std::string& icmp) = 0;
    virtual void onIcmpBlockInversionAdded(const std::string& zone) = 0;
    virtual void onIcmpBlockInversionRemoved(const std::string& zone) = 0;

public:
    std::map<std::string, sdbus::Variant> getZoneSettings2(const std::string& zone)
    {
        std::map<std::string, sdbus::Variant> result;
        m_proxy.callMethod("getZoneSettings2").onInterface(INTERFACE_NAME).withArguments(zone).storeResultsTo(result);
        return result;
    }

    void setZoneSettings2(const std::string& zone, const std::map<std::string, sdbus::Variant>& settings)
    {
        m_proxy.callMethod("setZoneSettings2").onInterface(INTERFACE_NAME).withArguments(zone, settings);
    }

    std::vector<std::string> getZones()
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getZones").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    std::map<std::string, std::map<std::string, std::vector<std::string>>> getActiveZones()
    {
        std::map<std::string, std::map<std::string, std::vector<std::string>>> result;
        m_proxy.callMethod("getActiveZones").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    std::string getZoneOfInterface(const std::string& interface)
    {
        std::string result;
        m_proxy.callMethod("getZoneOfInterface").onInterface(INTERFACE_NAME).withArguments(interface).storeResultsTo(result);
        return result;
    }

    std::string getZoneOfSource(const std::string& source)
    {
        std::string result;
        m_proxy.callMethod("getZoneOfSource").onInterface(INTERFACE_NAME).withArguments(source).storeResultsTo(result);
        return result;
    }

    bool isImmutable(const std::string& zone)
    {
        bool result;
        m_proxy.callMethod("isImmutable").onInterface(INTERFACE_NAME).withArguments(zone).storeResultsTo(result);
        return result;
    }

    std::string addInterface(const std::string& zone, const std::string& interface)
    {
        std::string result;
        m_proxy.callMethod("addInterface").onInterface(INTERFACE_NAME).withArguments(zone, interface).storeResultsTo(result);
        return result;
    }

    std::string changeZone(const std::string& zone, const std::string& interface)
    {
        std::string result;
        m_proxy.callMethod("changeZone").onInterface(INTERFACE_NAME).withArguments(zone, interface).storeResultsTo(result);
        return result;
    }

    std::string changeZoneOfInterface(const std::string& zone, const std::string& interface)
    {
        std::string result;
        m_proxy.callMethod("changeZoneOfInterface").onInterface(INTERFACE_NAME).withArguments(zone, interface).storeResultsTo(result);
        return result;
    }

    std::string removeInterface(const std::string& zone, const std::string& interface)
    {
        std::string result;
        m_proxy.callMethod("removeInterface").onInterface(INTERFACE_NAME).withArguments(zone, interface).storeResultsTo(result);
        return result;
    }

    bool queryInterface(const std::string& zone, const std::string& interface)
    {
        bool result;
        m_proxy.callMethod("queryInterface").onInterface(INTERFACE_NAME).withArguments(zone, interface).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getInterfaces(const std::string& zone)
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getInterfaces").onInterface(INTERFACE_NAME).withArguments(zone).storeResultsTo(result);
        return result;
    }

    std::string addSource(const std::string& zone, const std::string& source)
    {
        std::string result;
        m_proxy.callMethod("addSource").onInterface(INTERFACE_NAME).withArguments(zone, source).storeResultsTo(result);
        return result;
    }

    std::string changeZoneOfSource(const std::string& zone, const std::string& source)
    {
        std::string result;
        m_proxy.callMethod("changeZoneOfSource").onInterface(INTERFACE_NAME).withArguments(zone, source).storeResultsTo(result);
        return result;
    }

    std::string removeSource(const std::string& zone, const std::string& source)
    {
        std::string result;
        m_proxy.callMethod("removeSource").onInterface(INTERFACE_NAME).withArguments(zone, source).storeResultsTo(result);
        return result;
    }

    bool querySource(const std::string& zone, const std::string& source)
    {
        bool result;
        m_proxy.callMethod("querySource").onInterface(INTERFACE_NAME).withArguments(zone, source).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getSources(const std::string& zone)
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getSources").onInterface(INTERFACE_NAME).withArguments(zone).storeResultsTo(result);
        return result;
    }

    std::string addRichRule(const std::string& zone, const std::string& rule, const int32_t& timeout)
    {
        std::string result;
        m_proxy.callMethod("addRichRule").onInterface(INTERFACE_NAME).withArguments(zone, rule, timeout).storeResultsTo(result);
        return result;
    }

    std::string removeRichRule(const std::string& zone, const std::string& rule)
    {
        std::string result;
        m_proxy.callMethod("removeRichRule").onInterface(INTERFACE_NAME).withArguments(zone, rule).storeResultsTo(result);
        return result;
    }

    bool queryRichRule(const std::string& zone, const std::string& rule)
    {
        bool result;
        m_proxy.callMethod("queryRichRule").onInterface(INTERFACE_NAME).withArguments(zone, rule).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getRichRules(const std::string& zone)
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getRichRules").onInterface(INTERFACE_NAME).withArguments(zone).storeResultsTo(result);
        return result;
    }

    std::string addService(const std::string& zone, const std::string& service, const int32_t& timeout)
    {
        std::string result;
        m_proxy.callMethod("addService").onInterface(INTERFACE_NAME).withArguments(zone, service, timeout).storeResultsTo(result);
        return result;
    }

    std::string removeService(const std::string& zone, const std::string& service)
    {
        std::string result;
        m_proxy.callMethod("removeService").onInterface(INTERFACE_NAME).withArguments(zone, service).storeResultsTo(result);
        return result;
    }

    bool queryService(const std::string& zone, const std::string& service)
    {
        bool result;
        m_proxy.callMethod("queryService").onInterface(INTERFACE_NAME).withArguments(zone, service).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getServices(const std::string& zone)
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getServices").onInterface(INTERFACE_NAME).withArguments(zone).storeResultsTo(result);
        return result;
    }

    std::string addPort(const std::string& zone, const std::string& port, const std::string& protocol, const int32_t& timeout)
    {
        std::string result;
        m_proxy.callMethod("addPort").onInterface(INTERFACE_NAME).withArguments(zone, port, protocol, timeout).storeResultsTo(result);
        return result;
    }

    std::string removePort(const std::string& zone, const std::string& port, const std::string& protocol)
    {
        std::string result;
        m_proxy.callMethod("removePort").onInterface(INTERFACE_NAME).withArguments(zone, port, protocol).storeResultsTo(result);
        return result;
    }

    bool queryPort(const std::string& zone, const std::string& port, const std::string& protocol)
    {
        bool result;
        m_proxy.callMethod("queryPort").onInterface(INTERFACE_NAME).withArguments(zone, port, protocol).storeResultsTo(result);
        return result;
    }

    std::vector<std::vector<std::string>> getPorts(const std::string& zone)
    {
        std::vector<std::vector<std::string>> result;
        m_proxy.callMethod("getPorts").onInterface(INTERFACE_NAME).withArguments(zone).storeResultsTo(result);
        return result;
    }

    std::string addProtocol(const std::string& zone, const std::string& protocol, const int32_t& timeout)
    {
        std::string result;
        m_proxy.callMethod("addProtocol").onInterface(INTERFACE_NAME).withArguments(zone, protocol, timeout).storeResultsTo(result);
        return result;
    }

    std::string removeProtocol(const std::string& zone, const std::string& protocol)
    {
        std::string result;
        m_proxy.callMethod("removeProtocol").onInterface(INTERFACE_NAME).withArguments(zone, protocol).storeResultsTo(result);
        return result;
    }

    bool queryProtocol(const std::string& zone, const std::string& protocol)
    {
        bool result;
        m_proxy.callMethod("queryProtocol").onInterface(INTERFACE_NAME).withArguments(zone, protocol).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getProtocols(const std::string& zone)
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getProtocols").onInterface(INTERFACE_NAME).withArguments(zone).storeResultsTo(result);
        return result;
    }

    std::string addSourcePort(const std::string& zone, const std::string& port, const std::string& protocol, const int32_t& timeout)
    {
        std::string result;
        m_proxy.callMethod("addSourcePort").onInterface(INTERFACE_NAME).withArguments(zone, port, protocol, timeout).storeResultsTo(result);
        return result;
    }

    std::string removeSourcePort(const std::string& zone, const std::string& port, const std::string& protocol)
    {
        std::string result;
        m_proxy.callMethod("removeSourcePort").onInterface(INTERFACE_NAME).withArguments(zone, port, protocol).storeResultsTo(result);
        return result;
    }

    bool querySourcePort(const std::string& zone, const std::string& port, const std::string& protocol)
    {
        bool result;
        m_proxy.callMethod("querySourcePort").onInterface(INTERFACE_NAME).withArguments(zone, port, protocol).storeResultsTo(result);
        return result;
    }

    std::vector<std::vector<std::string>> getSourcePorts(const std::string& zone)
    {
        std::vector<std::vector<std::string>> result;
        m_proxy.callMethod("getSourcePorts").onInterface(INTERFACE_NAME).withArguments(zone).storeResultsTo(result);
        return result;
    }

    std::string addMasquerade(const std::string& zone, const int32_t& timeout)
    {
        std::string result;
        m_proxy.callMethod("addMasquerade").onInterface(INTERFACE_NAME).withArguments(zone, timeout).storeResultsTo(result);
        return result;
    }

    std::string removeMasquerade(const std::string& zone)
    {
        std::string result;
        m_proxy.callMethod("removeMasquerade").onInterface(INTERFACE_NAME).withArguments(zone).storeResultsTo(result);
        return result;
    }

    bool queryMasquerade(const std::string& zone)
    {
        bool result;
        m_proxy.callMethod("queryMasquerade").onInterface(INTERFACE_NAME).withArguments(zone).storeResultsTo(result);
        return result;
    }

    std::string addForwardPort(const std::string& zone, const std::string& port, const std::string& protocol, const std::string& toport, const std::string& toaddr, const int32_t& timeout)
    {
        std::string result;
        m_proxy.callMethod("addForwardPort").onInterface(INTERFACE_NAME).withArguments(zone, port, protocol, toport, toaddr, timeout).storeResultsTo(result);
        return result;
    }

    std::string removeForwardPort(const std::string& zone, const std::string& port, const std::string& protocol, const std::string& toport, const std::string& toaddr)
    {
        std::string result;
        m_proxy.callMethod("removeForwardPort").onInterface(INTERFACE_NAME).withArguments(zone, port, protocol, toport, toaddr).storeResultsTo(result);
        return result;
    }

    bool queryForwardPort(const std::string& zone, const std::string& port, const std::string& protocol, const std::string& toport, const std::string& toaddr)
    {
        bool result;
        m_proxy.callMethod("queryForwardPort").onInterface(INTERFACE_NAME).withArguments(zone, port, protocol, toport, toaddr).storeResultsTo(result);
        return result;
    }

    std::vector<std::vector<std::string>> getForwardPorts(const std::string& zone)
    {
        std::vector<std::vector<std::string>> result;
        m_proxy.callMethod("getForwardPorts").onInterface(INTERFACE_NAME).withArguments(zone).storeResultsTo(result);
        return result;
    }

    std::string addIcmpBlock(const std::string& zone, const std::string& icmp, const int32_t& timeout)
    {
        std::string result;
        m_proxy.callMethod("addIcmpBlock").onInterface(INTERFACE_NAME).withArguments(zone, icmp, timeout).storeResultsTo(result);
        return result;
    }

    std::string removeIcmpBlock(const std::string& zone, const std::string& icmp)
    {
        std::string result;
        m_proxy.callMethod("removeIcmpBlock").onInterface(INTERFACE_NAME).withArguments(zone, icmp).storeResultsTo(result);
        return result;
    }

    bool queryIcmpBlock(const std::string& zone, const std::string& icmp)
    {
        bool result;
        m_proxy.callMethod("queryIcmpBlock").onInterface(INTERFACE_NAME).withArguments(zone, icmp).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getIcmpBlocks(const std::string& zone)
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getIcmpBlocks").onInterface(INTERFACE_NAME).withArguments(zone).storeResultsTo(result);
        return result;
    }

    std::string addIcmpBlockInversion(const std::string& zone)
    {
        std::string result;
        m_proxy.callMethod("addIcmpBlockInversion").onInterface(INTERFACE_NAME).withArguments(zone).storeResultsTo(result);
        return result;
    }

    std::string removeIcmpBlockInversion(const std::string& zone)
    {
        std::string result;
        m_proxy.callMethod("removeIcmpBlockInversion").onInterface(INTERFACE_NAME).withArguments(zone).storeResultsTo(result);
        return result;
    }

    bool queryIcmpBlockInversion(const std::string& zone)
    {
        bool result;
        m_proxy.callMethod("queryIcmpBlockInversion").onInterface(INTERFACE_NAME).withArguments(zone).storeResultsTo(result);
        return result;
    }

private:
    sdbus::IProxy& m_proxy;
};

}}} // namespaces

namespace org {
namespace fedoraproject {
namespace FirewallD1 {

class policy_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.fedoraproject.FirewallD1.policy";

protected:
    policy_proxy(sdbus::IProxy& proxy)
        : m_proxy(proxy)
    {
    }

    policy_proxy(const policy_proxy&) = delete;
    policy_proxy& operator=(const policy_proxy&) = delete;
    policy_proxy(policy_proxy&&) = delete;
    policy_proxy& operator=(policy_proxy&&) = delete;

    ~policy_proxy() = default;

    void registerProxy()
    {
        m_proxy.uponSignal("PolicyUpdated").onInterface(INTERFACE_NAME).call([this](const std::string& policy, const std::map<std::string, sdbus::Variant>& settings){ this->onPolicyUpdated(policy, settings); });
    }

    virtual void onPolicyUpdated(const std::string& policy, const std::map<std::string, sdbus::Variant>& settings) = 0;

public:
    std::map<std::string, sdbus::Variant> getPolicySettings(const std::string& policy)
    {
        std::map<std::string, sdbus::Variant> result;
        m_proxy.callMethod("getPolicySettings").onInterface(INTERFACE_NAME).withArguments(policy).storeResultsTo(result);
        return result;
    }

    void setPolicySettings(const std::string& policy, const std::map<std::string, sdbus::Variant>& settings)
    {
        m_proxy.callMethod("setPolicySettings").onInterface(INTERFACE_NAME).withArguments(policy, settings);
    }

    std::vector<std::string> getPolicies()
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getPolicies").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    std::map<std::string, std::map<std::string, std::vector<std::string>>> getActivePolicies()
    {
        std::map<std::string, std::map<std::string, std::vector<std::string>>> result;
        m_proxy.callMethod("getActivePolicies").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

private:
    sdbus::IProxy& m_proxy;
};

}}} // namespaces

namespace org {
namespace fedoraproject {
namespace FirewallD1 {

class direct_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.fedoraproject.FirewallD1.direct";

protected:
    direct_proxy(sdbus::IProxy& proxy)
        : m_proxy(proxy)
    {
    }

    direct_proxy(const direct_proxy&) = delete;
    direct_proxy& operator=(const direct_proxy&) = delete;
    direct_proxy(direct_proxy&&) = delete;
    direct_proxy& operator=(direct_proxy&&) = delete;

    ~direct_proxy() = default;

    void registerProxy()
    {
        m_proxy.uponSignal("ChainAdded").onInterface(INTERFACE_NAME).call([this](const std::string& ipv, const std::string& table, const std::string& chain){ this->onChainAdded(ipv, table, chain); });
        m_proxy.uponSignal("ChainRemoved").onInterface(INTERFACE_NAME).call([this](const std::string& ipv, const std::string& table, const std::string& chain){ this->onChainRemoved(ipv, table, chain); });
        m_proxy.uponSignal("RuleAdded").onInterface(INTERFACE_NAME).call([this](const std::string& ipv, const std::string& table, const std::string& chain, const int32_t& priority, const std::vector<std::string>& args){ this->onRuleAdded(ipv, table, chain, priority, args); });
        m_proxy.uponSignal("RuleRemoved").onInterface(INTERFACE_NAME).call([this](const std::string& ipv, const std::string& table, const std::string& chain, const int32_t& priority, const std::vector<std::string>& args){ this->onRuleRemoved(ipv, table, chain, priority, args); });
        m_proxy.uponSignal("PassthroughAdded").onInterface(INTERFACE_NAME).call([this](const std::string& ipv, const std::vector<std::string>& args){ this->onPassthroughAdded(ipv, args); });
        m_proxy.uponSignal("PassthroughRemoved").onInterface(INTERFACE_NAME).call([this](const std::string& ipv, const std::vector<std::string>& args){ this->onPassthroughRemoved(ipv, args); });
    }

    virtual void onChainAdded(const std::string& ipv, const std::string& table, const std::string& chain) = 0;
    virtual void onChainRemoved(const std::string& ipv, const std::string& table, const std::string& chain) = 0;
    virtual void onRuleAdded(const std::string& ipv, const std::string& table, const std::string& chain, const int32_t& priority, const std::vector<std::string>& args) = 0;
    virtual void onRuleRemoved(const std::string& ipv, const std::string& table, const std::string& chain, const int32_t& priority, const std::vector<std::string>& args) = 0;
    virtual void onPassthroughAdded(const std::string& ipv, const std::vector<std::string>& args) = 0;
    virtual void onPassthroughRemoved(const std::string& ipv, const std::vector<std::string>& args) = 0;

public:
    void addChain(const std::string& ipv, const std::string& table, const std::string& chain)
    {
        m_proxy.callMethod("addChain").onInterface(INTERFACE_NAME).withArguments(ipv, table, chain);
    }

    void removeChain(const std::string& ipv, const std::string& table, const std::string& chain)
    {
        m_proxy.callMethod("removeChain").onInterface(INTERFACE_NAME).withArguments(ipv, table, chain);
    }

    bool queryChain(const std::string& ipv, const std::string& table, const std::string& chain)
    {
        bool result;
        m_proxy.callMethod("queryChain").onInterface(INTERFACE_NAME).withArguments(ipv, table, chain).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getChains(const std::string& ipv, const std::string& table)
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getChains").onInterface(INTERFACE_NAME).withArguments(ipv, table).storeResultsTo(result);
        return result;
    }

    std::vector<sdbus::Struct<std::string, std::string, std::string>> getAllChains()
    {
        std::vector<sdbus::Struct<std::string, std::string, std::string>> result;
        m_proxy.callMethod("getAllChains").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    void addRule(const std::string& ipv, const std::string& table, const std::string& chain, const int32_t& priority, const std::vector<std::string>& args)
    {
        m_proxy.callMethod("addRule").onInterface(INTERFACE_NAME).withArguments(ipv, table, chain, priority, args);
    }

    void removeRule(const std::string& ipv, const std::string& table, const std::string& chain, const int32_t& priority, const std::vector<std::string>& args)
    {
        m_proxy.callMethod("removeRule").onInterface(INTERFACE_NAME).withArguments(ipv, table, chain, priority, args);
    }

    void removeRules(const std::string& ipv, const std::string& table, const std::string& chain)
    {
        m_proxy.callMethod("removeRules").onInterface(INTERFACE_NAME).withArguments(ipv, table, chain);
    }

    bool queryRule(const std::string& ipv, const std::string& table, const std::string& chain, const int32_t& priority, const std::vector<std::string>& args)
    {
        bool result;
        m_proxy.callMethod("queryRule").onInterface(INTERFACE_NAME).withArguments(ipv, table, chain, priority, args).storeResultsTo(result);
        return result;
    }

    std::vector<sdbus::Struct<int32_t, std::vector<std::string>>> getRules(const std::string& ipv, const std::string& table, const std::string& chain)
    {
        std::vector<sdbus::Struct<int32_t, std::vector<std::string>>> result;
        m_proxy.callMethod("getRules").onInterface(INTERFACE_NAME).withArguments(ipv, table, chain).storeResultsTo(result);
        return result;
    }

    std::vector<sdbus::Struct<std::string, std::string, std::string, int32_t, std::vector<std::string>>> getAllRules()
    {
        std::vector<sdbus::Struct<std::string, std::string, std::string, int32_t, std::vector<std::string>>> result;
        m_proxy.callMethod("getAllRules").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    std::string passthrough(const std::string& ipv, const std::vector<std::string>& args)
    {
        std::string result;
        m_proxy.callMethod("passthrough").onInterface(INTERFACE_NAME).withArguments(ipv, args).storeResultsTo(result);
        return result;
    }

    void addPassthrough(const std::string& ipv, const std::vector<std::string>& args)
    {
        m_proxy.callMethod("addPassthrough").onInterface(INTERFACE_NAME).withArguments(ipv, args);
    }

    void removePassthrough(const std::string& ipv, const std::vector<std::string>& args)
    {
        m_proxy.callMethod("removePassthrough").onInterface(INTERFACE_NAME).withArguments(ipv, args);
    }

    bool queryPassthrough(const std::string& ipv, const std::vector<std::string>& args)
    {
        bool result;
        m_proxy.callMethod("queryPassthrough").onInterface(INTERFACE_NAME).withArguments(ipv, args).storeResultsTo(result);
        return result;
    }

    std::vector<sdbus::Struct<std::string, std::vector<std::string>>> getAllPassthroughs()
    {
        std::vector<sdbus::Struct<std::string, std::vector<std::string>>> result;
        m_proxy.callMethod("getAllPassthroughs").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    void removeAllPassthroughs()
    {
        m_proxy.callMethod("removeAllPassthroughs").onInterface(INTERFACE_NAME);
    }

    std::vector<std::vector<std::string>> getPassthroughs(const std::string& ipv)
    {
        std::vector<std::vector<std::string>> result;
        m_proxy.callMethod("getPassthroughs").onInterface(INTERFACE_NAME).withArguments(ipv).storeResultsTo(result);
        return result;
    }

private:
    sdbus::IProxy& m_proxy;
};

}}} // namespaces

namespace org {
namespace fedoraproject {
namespace FirewallD1 {

class ipset_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.fedoraproject.FirewallD1.ipset";

protected:
    ipset_proxy(sdbus::IProxy& proxy)
        : m_proxy(proxy)
    {
    }

    ipset_proxy(const ipset_proxy&) = delete;
    ipset_proxy& operator=(const ipset_proxy&) = delete;
    ipset_proxy(ipset_proxy&&) = delete;
    ipset_proxy& operator=(ipset_proxy&&) = delete;

    ~ipset_proxy() = default;

    void registerProxy()
    {
        m_proxy.uponSignal("EntryAdded").onInterface(INTERFACE_NAME).call([this](const std::string& ipset, const std::string& entry){ this->onEntryAdded(ipset, entry); });
        m_proxy.uponSignal("EntryRemoved").onInterface(INTERFACE_NAME).call([this](const std::string& ipset, const std::string& entry){ this->onEntryRemoved(ipset, entry); });
    }

    virtual void onEntryAdded(const std::string& ipset, const std::string& entry) = 0;
    virtual void onEntryRemoved(const std::string& ipset, const std::string& entry) = 0;

public:
    bool queryIPSet(const std::string& ipset)
    {
        bool result;
        m_proxy.callMethod("queryIPSet").onInterface(INTERFACE_NAME).withArguments(ipset).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getIPSets()
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getIPSets").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    sdbus::Struct<std::string, std::string, std::string, std::string, std::map<std::string, std::string>, std::vector<std::string>> getIPSetSettings(const std::string& ipset)
    {
        sdbus::Struct<std::string, std::string, std::string, std::string, std::map<std::string, std::string>, std::vector<std::string>> result;
        m_proxy.callMethod("getIPSetSettings").onInterface(INTERFACE_NAME).withArguments(ipset).storeResultsTo(result);
        return result;
    }

    void addEntry(const std::string& ipset, const std::string& entry)
    {
        m_proxy.callMethod("addEntry").onInterface(INTERFACE_NAME).withArguments(ipset, entry);
    }

    void removeEntry(const std::string& ipset, const std::string& entry)
    {
        m_proxy.callMethod("removeEntry").onInterface(INTERFACE_NAME).withArguments(ipset, entry);
    }

    bool queryEntry(const std::string& ipset, const std::string& entry)
    {
        bool result;
        m_proxy.callMethod("queryEntry").onInterface(INTERFACE_NAME).withArguments(ipset, entry).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getEntries(const std::string& ipset)
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getEntries").onInterface(INTERFACE_NAME).withArguments(ipset).storeResultsTo(result);
        return result;
    }

    void setEntries(const std::string& ipset, const std::vector<std::string>& entries)
    {
        m_proxy.callMethod("setEntries").onInterface(INTERFACE_NAME).withArguments(ipset, entries);
    }

private:
    sdbus::IProxy& m_proxy;
};

}}} // namespaces

#endif


/*
 * This file was automatically generated by sdbus-c++-xml2cpp; DO NOT EDIT!
 */

#ifndef __sdbuscpp__firewalld_proxy_sdbus_2_FirewallD1_Config_Proxy_h__proxy__H__
#define __sdbuscpp__firewalld_proxy_sdbus_2_FirewallD1_Config_Proxy_h__proxy__H__

#include <sdbus-c++/sdbus-c++.h>
#include <string>
#include <tuple>

namespace org {
namespace fedoraproject {
namespace FirewallD1 {
namespace config {

class policies_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.fedoraproject.FirewallD1.config.policies";

protected:
    policies_proxy(sdbus::IProxy& proxy)
        : m_proxy(proxy)
    {
    }

    policies_proxy(const policies_proxy&) = delete;
    policies_proxy& operator=(const policies_proxy&) = delete;
    policies_proxy(policies_proxy&&) = delete;
    policies_proxy& operator=(policies_proxy&&) = delete;

    ~policies_proxy() = default;

    void registerProxy()
    {
        m_proxy.uponSignal("LockdownWhitelistUpdated").onInterface(INTERFACE_NAME).call([this](){ this->onLockdownWhitelistUpdated(); });
    }

    virtual void onLockdownWhitelistUpdated() = 0;

public:
    sdbus::Struct<std::vector<std::string>, std::vector<std::string>, std::vector<std::string>, std::vector<int32_t>> getLockdownWhitelist()
    {
        sdbus::Struct<std::vector<std::string>, std::vector<std::string>, std::vector<std::string>, std::vector<int32_t>> result;
        m_proxy.callMethod("getLockdownWhitelist").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    void setLockdownWhitelist(const sdbus::Struct<std::vector<std::string>, std::vector<std::string>, std::vector<std::string>, std::vector<int32_t>>& settings)
    {
        m_proxy.callMethod("setLockdownWhitelist").onInterface(INTERFACE_NAME).withArguments(settings);
    }

    void addLockdownWhitelistCommand(const std::string& command)
    {
        m_proxy.callMethod("addLockdownWhitelistCommand").onInterface(INTERFACE_NAME).withArguments(command);
    }

    void removeLockdownWhitelistCommand(const std::string& command)
    {
        m_proxy.callMethod("removeLockdownWhitelistCommand").onInterface(INTERFACE_NAME).withArguments(command);
    }

    bool queryLockdownWhitelistCommand(const std::string& command)
    {
        bool result;
        m_proxy.callMethod("queryLockdownWhitelistCommand").onInterface(INTERFACE_NAME).withArguments(command).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getLockdownWhitelistCommands()
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getLockdownWhitelistCommands").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    void addLockdownWhitelistContext(const std::string& context)
    {
        m_proxy.callMethod("addLockdownWhitelistContext").onInterface(INTERFACE_NAME).withArguments(context);
    }

    void removeLockdownWhitelistContext(const std::string& context)
    {
        m_proxy.callMethod("removeLockdownWhitelistContext").onInterface(INTERFACE_NAME).withArguments(context);
    }

    bool queryLockdownWhitelistContext(const std::string& context)
    {
        bool result;
        m_proxy.callMethod("queryLockdownWhitelistContext").onInterface(INTERFACE_NAME).withArguments(context).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getLockdownWhitelistContexts()
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getLockdownWhitelistContexts").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    void addLockdownWhitelistUser(const std::string& user)
    {
        m_proxy.callMethod("addLockdownWhitelistUser").onInterface(INTERFACE_NAME).withArguments(user);
    }

    void removeLockdownWhitelistUser(const std::string& user)
    {
        m_proxy.callMethod("removeLockdownWhitelistUser").onInterface(INTERFACE_NAME).withArguments(user);
    }

    bool queryLockdownWhitelistUser(const std::string& user)
    {
        bool result;
        m_proxy.callMethod("queryLockdownWhitelistUser").onInterface(INTERFACE_NAME).withArguments(user).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getLockdownWhitelistUsers()
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getLockdownWhitelistUsers").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    void addLockdownWhitelistUid(const int32_t& uid)
    {
        m_proxy.callMethod("addLockdownWhitelistUid").onInterface(INTERFACE_NAME).withArguments(uid);
    }

    void removeLockdownWhitelistUid(const int32_t& uid)
    {
        m_proxy.callMethod("removeLockdownWhitelistUid").onInterface(INTERFACE_NAME).withArguments(uid);
    }

    bool queryLockdownWhitelistUid(const int32_t& uid)
    {
        bool result;
        m_proxy.callMethod("queryLockdownWhitelistUid").onInterface(INTERFACE_NAME).withArguments(uid).storeResultsTo(result);
        return result;
    }

    std::vector<int32_t> getLockdownWhitelistUids()
    {
        std::vector<int32_t> result;
        m_proxy.callMethod("getLockdownWhitelistUids").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

private:
    sdbus::IProxy& m_proxy;
};

}}}} // namespaces

namespace org {
namespace fedoraproject {
namespace FirewallD1 {

class config_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.fedoraproject.FirewallD1.config";

protected:
    config_proxy(sdbus::IProxy& proxy)
        : m_proxy(proxy)
    {
    }

    config_proxy(const config_proxy&) = delete;
    config_proxy& operator=(const config_proxy&) = delete;
    config_proxy(config_proxy&&) = delete;
    config_proxy& operator=(config_proxy&&) = delete;

    ~config_proxy() = default;

    void registerProxy()
    {
        m_proxy.uponSignal("IPSetAdded").onInterface(INTERFACE_NAME).call([this](const std::string& ipset){ this->onIPSetAdded(ipset); });
        m_proxy.uponSignal("IcmpTypeAdded").onInterface(INTERFACE_NAME).call([this](const std::string& icmptype){ this->onIcmpTypeAdded(icmptype); });
        m_proxy.uponSignal("ServiceAdded").onInterface(INTERFACE_NAME).call([this](const std::string& service){ this->onServiceAdded(service); });
        m_proxy.uponSignal("ZoneAdded").onInterface(INTERFACE_NAME).call([this](const std::string& zone){ this->onZoneAdded(zone); });
        m_proxy.uponSignal("PolicyAdded").onInterface(INTERFACE_NAME).call([this](const std::string& policy){ this->onPolicyAdded(policy); });
        m_proxy.uponSignal("HelperAdded").onInterface(INTERFACE_NAME).call([this](const std::string& helper){ this->onHelperAdded(helper); });
    }

    virtual void onIPSetAdded(const std::string& ipset) = 0;
    virtual void onIcmpTypeAdded(const std::string& icmptype) = 0;
    virtual void onServiceAdded(const std::string& service) = 0;
    virtual void onZoneAdded(const std::string& zone) = 0;
    virtual void onPolicyAdded(const std::string& policy) = 0;
    virtual void onHelperAdded(const std::string& helper) = 0;

public:
    std::vector<sdbus::ObjectPath> listIPSets()
    {
        std::vector<sdbus::ObjectPath> result;
        m_proxy.callMethod("listIPSets").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getIPSetNames()
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getIPSetNames").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    sdbus::ObjectPath getIPSetByName(const std::string& ipset)
    {
        sdbus::ObjectPath result;
        m_proxy.callMethod("getIPSetByName").onInterface(INTERFACE_NAME).withArguments(ipset).storeResultsTo(result);
        return result;
    }

    sdbus::ObjectPath addIPSet(const std::string& ipset, const sdbus::Struct<std::string, std::string, std::string, std::string, std::map<std::string, std::string>, std::vector<std::string>>& settings)
    {
        sdbus::ObjectPath result;
        m_proxy.callMethod("addIPSet").onInterface(INTERFACE_NAME).withArguments(ipset, settings).storeResultsTo(result);
        return result;
    }

    std::vector<sdbus::ObjectPath> listIcmpTypes()
    {
        std::vector<sdbus::ObjectPath> result;
        m_proxy.callMethod("listIcmpTypes").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getIcmpTypeNames()
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getIcmpTypeNames").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    sdbus::ObjectPath getIcmpTypeByName(const std::string& icmptype)
    {
        sdbus::ObjectPath result;
        m_proxy.callMethod("getIcmpTypeByName").onInterface(INTERFACE_NAME).withArguments(icmptype).storeResultsTo(result);
        return result;
    }

    sdbus::ObjectPath addIcmpType(const std::string& icmptype, const sdbus::Struct<std::string, std::string, std::string, std::vector<std::string>>& settings)
    {
        sdbus::ObjectPath result;
        m_proxy.callMethod("addIcmpType").onInterface(INTERFACE_NAME).withArguments(icmptype, settings).storeResultsTo(result);
        return result;
    }

    std::vector<sdbus::ObjectPath> listServices()
    {
        std::vector<sdbus::ObjectPath> result;
        m_proxy.callMethod("listServices").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getServiceNames()
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getServiceNames").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    sdbus::ObjectPath getServiceByName(const std::string& service)
    {
        sdbus::ObjectPath result;
        m_proxy.callMethod("getServiceByName").onInterface(INTERFACE_NAME).withArguments(service).storeResultsTo(result);
        return result;
    }

    sdbus::ObjectPath addService(const std::string& service, const sdbus::Struct<std::string, std::string, std::string, std::vector<sdbus::Struct<std::string, std::string>>, std::vector<std::string>, std::map<std::string, std::string>, std::vector<std::string>, std::vector<sdbus::Struct<std::string, std::string>>>& settings)
    {
        sdbus::ObjectPath result;
        m_proxy.callMethod("addService").onInterface(INTERFACE_NAME).withArguments(service, settings).storeResultsTo(result);
        return result;
    }

    sdbus::ObjectPath addService2(const std::string& service, const std::map<std::string, sdbus::Variant>& settings)
    {
        sdbus::ObjectPath result;
        m_proxy.callMethod("addService2").onInterface(INTERFACE_NAME).withArguments(service, settings).storeResultsTo(result);
        return result;
    }

    std::vector<sdbus::ObjectPath> listZones()
    {
        std::vector<sdbus::ObjectPath> result;
        m_proxy.callMethod("listZones").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getZoneNames()
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getZoneNames").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    sdbus::ObjectPath getZoneByName(const std::string& zone)
    {
        sdbus::ObjectPath result;
        m_proxy.callMethod("getZoneByName").onInterface(INTERFACE_NAME).withArguments(zone).storeResultsTo(result);
        return result;
    }

    std::string getZoneOfInterface(const std::string& iface)
    {
        std::string result;
        m_proxy.callMethod("getZoneOfInterface").onInterface(INTERFACE_NAME).withArguments(iface).storeResultsTo(result);
        return result;
    }

    std::string getZoneOfSource(const std::string& source)
    {
        std::string result;
        m_proxy.callMethod("getZoneOfSource").onInterface(INTERFACE_NAME).withArguments(source).storeResultsTo(result);
        return result;
    }

    sdbus::ObjectPath addZone(const std::string& zone, const sdbus::Struct<std::string, std::string, std::string, bool, std::string, std::vector<std::string>, std::vector<sdbus::Struct<std::string, std::string>>, std::vector<std::string>, bool, std::vector<sdbus::Struct<std::string, std::string, std::string, std::string>>, std::vector<std::string>, std::vector<std::string>, std::vector<std::string>, std::vector<std::string>, std::vector<sdbus::Struct<std::string, std::string>>, bool>& settings)
    {
        sdbus::ObjectPath result;
        m_proxy.callMethod("addZone").onInterface(INTERFACE_NAME).withArguments(zone, settings).storeResultsTo(result);
        return result;
    }

    sdbus::ObjectPath addZone2(const std::string& zone, const std::map<std::string, sdbus::Variant>& settings)
    {
        sdbus::ObjectPath result;
        m_proxy.callMethod("addZone2").onInterface(INTERFACE_NAME).withArguments(zone, settings).storeResultsTo(result);
        return result;
    }

    std::vector<sdbus::ObjectPath> listPolicies()
    {
        std::vector<sdbus::ObjectPath> result;
        m_proxy.callMethod("listPolicies").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getPolicyNames()
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getPolicyNames").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    sdbus::ObjectPath getPolicyByName(const std::string& policy)
    {
        sdbus::ObjectPath result;
        m_proxy.callMethod("getPolicyByName").onInterface(INTERFACE_NAME).withArguments(policy).storeResultsTo(result);
        return result;
    }

    sdbus::ObjectPath addPolicy(const std::string& policy, const std::map<std::string, sdbus::Variant>& settings)
    {
        sdbus::ObjectPath result;
        m_proxy.callMethod("addPolicy").onInterface(INTERFACE_NAME).withArguments(policy, settings).storeResultsTo(result);
        return result;
    }

    std::vector<sdbus::ObjectPath> listHelpers()
    {
        std::vector<sdbus::ObjectPath> result;
        m_proxy.callMethod("listHelpers").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getHelperNames()
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getHelperNames").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    sdbus::ObjectPath getHelperByName(const std::string& helper)
    {
        sdbus::ObjectPath result;
        m_proxy.callMethod("getHelperByName").onInterface(INTERFACE_NAME).withArguments(helper).storeResultsTo(result);
        return result;
    }

    sdbus::ObjectPath addHelper(const std::string& helper, const sdbus::Struct<std::string, std::string, std::string, std::string, std::string, std::vector<sdbus::Struct<std::string, std::string>>>& settings)
    {
        sdbus::ObjectPath result;
        m_proxy.callMethod("addHelper").onInterface(INTERFACE_NAME).withArguments(helper, settings).storeResultsTo(result);
        return result;
    }

public:
    std::string DefaultZone()
    {
        return m_proxy.getProperty("DefaultZone").onInterface(INTERFACE_NAME).get<std::string>();
    }

    int32_t MinimalMark()
    {
        return m_proxy.getProperty("MinimalMark").onInterface(INTERFACE_NAME).get<int32_t>();
    }

    void MinimalMark(const int32_t& value)
    {
        m_proxy.setProperty("MinimalMark").onInterface(INTERFACE_NAME).toValue(value);
    }

    std::string CleanupOnExit()
    {
        return m_proxy.getProperty("CleanupOnExit").onInterface(INTERFACE_NAME).get<std::string>();
    }

    void CleanupOnExit(const std::string& value)
    {
        m_proxy.setProperty("CleanupOnExit").onInterface(INTERFACE_NAME).toValue(value);
    }

    std::string CleanupModulesOnExit()
    {
        return m_proxy.getProperty("CleanupModulesOnExit").onInterface(INTERFACE_NAME).get<std::string>();
    }

    void CleanupModulesOnExit(const std::string& value)
    {
        m_proxy.setProperty("CleanupModulesOnExit").onInterface(INTERFACE_NAME).toValue(value);
    }

    std::string IPv6_rpfilter()
    {
        return m_proxy.getProperty("IPv6_rpfilter").onInterface(INTERFACE_NAME).get<std::string>();
    }

    void IPv6_rpfilter(const std::string& value)
    {
        m_proxy.setProperty("IPv6_rpfilter").onInterface(INTERFACE_NAME).toValue(value);
    }

    std::string IPv6_rpfilter2()
    {
        return m_proxy.getProperty("IPv6_rpfilter2").onInterface(INTERFACE_NAME).get<std::string>();
    }

    void IPv6_rpfilter2(const std::string& value)
    {
        m_proxy.setProperty("IPv6_rpfilter2").onInterface(INTERFACE_NAME).toValue(value);
    }

    std::string Lockdown()
    {
        return m_proxy.getProperty("Lockdown").onInterface(INTERFACE_NAME).get<std::string>();
    }

    void Lockdown(const std::string& value)
    {
        m_proxy.setProperty("Lockdown").onInterface(INTERFACE_NAME).toValue(value);
    }

    std::string IndividualCalls()
    {
        return m_proxy.getProperty("IndividualCalls").onInterface(INTERFACE_NAME).get<std::string>();
    }

    void IndividualCalls(const std::string& value)
    {
        m_proxy.setProperty("IndividualCalls").onInterface(INTERFACE_NAME).toValue(value);
    }

    std::string LogDenied()
    {
        return m_proxy.getProperty("LogDenied").onInterface(INTERFACE_NAME).get<std::string>();
    }

    void LogDenied(const std::string& value)
    {
        m_proxy.setProperty("LogDenied").onInterface(INTERFACE_NAME).toValue(value);
    }

    std::string AutomaticHelpers()
    {
        return m_proxy.getProperty("AutomaticHelpers").onInterface(INTERFACE_NAME).get<std::string>();
    }

    void AutomaticHelpers(const std::string& value)
    {
        m_proxy.setProperty("AutomaticHelpers").onInterface(INTERFACE_NAME).toValue(value);
    }

    std::string FirewallBackend()
    {
        return m_proxy.getProperty("FirewallBackend").onInterface(INTERFACE_NAME).get<std::string>();
    }

    void FirewallBackend(const std::string& value)
    {
        m_proxy.setProperty("FirewallBackend").onInterface(INTERFACE_NAME).toValue(value);
    }

    std::string FlushAllOnReload()
    {
        return m_proxy.getProperty("FlushAllOnReload").onInterface(INTERFACE_NAME).get<std::string>();
    }

    void FlushAllOnReload(const std::string& value)
    {
        m_proxy.setProperty("FlushAllOnReload").onInterface(INTERFACE_NAME).toValue(value);
    }

    std::string RFC3964_IPv4()
    {
        return m_proxy.getProperty("RFC3964_IPv4").onInterface(INTERFACE_NAME).get<std::string>();
    }

    void RFC3964_IPv4(const std::string& value)
    {
        m_proxy.setProperty("RFC3964_IPv4").onInterface(INTERFACE_NAME).toValue(value);
    }

    std::string AllowZoneDrifting()
    {
        return m_proxy.getProperty("AllowZoneDrifting").onInterface(INTERFACE_NAME).get<std::string>();
    }

    void AllowZoneDrifting(const std::string& value)
    {
        m_proxy.setProperty("AllowZoneDrifting").onInterface(INTERFACE_NAME).toValue(value);
    }

    std::string NftablesFlowtable()
    {
        return m_proxy.getProperty("NftablesFlowtable").onInterface(INTERFACE_NAME).get<std::string>();
    }

    void NftablesFlowtable(const std::string& value)
    {
        m_proxy.setProperty("NftablesFlowtable").onInterface(INTERFACE_NAME).toValue(value);
    }

    std::string NftablesCounters()
    {
        return m_proxy.getProperty("NftablesCounters").onInterface(INTERFACE_NAME).get<std::string>();
    }

    void NftablesCounters(const std::string& value)
    {
        m_proxy.setProperty("NftablesCounters").onInterface(INTERFACE_NAME).toValue(value);
    }

    std::string NftablesTableOwner()
    {
        return m_proxy.getProperty("NftablesTableOwner").onInterface(INTERFACE_NAME).get<std::string>();
    }

    void NftablesTableOwner(const std::string& value)
    {
        m_proxy.setProperty("NftablesTableOwner").onInterface(INTERFACE_NAME).toValue(value);
    }

    std::string StrictForwardPorts()
    {
        return m_proxy.getProperty("StrictForwardPorts").onInterface(INTERFACE_NAME).get<std::string>();
    }

    void StrictForwardPorts(const std::string& value)
    {
        m_proxy.setProperty("StrictForwardPorts").onInterface(INTERFACE_NAME).toValue(value);
    }

private:
    sdbus::IProxy& m_proxy;
};

}}} // namespaces

namespace org {
namespace fedoraproject {
namespace FirewallD1 {
namespace config {

class direct_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.fedoraproject.FirewallD1.config.direct";

protected:
    direct_proxy(sdbus::IProxy& proxy)
        : m_proxy(proxy)
    {
    }

    direct_proxy(const direct_proxy&) = delete;
    direct_proxy& operator=(const direct_proxy&) = delete;
    direct_proxy(direct_proxy&&) = delete;
    direct_proxy& operator=(direct_proxy&&) = delete;

    ~direct_proxy() = default;

    void registerProxy()
    {
        m_proxy.uponSignal("Updated").onInterface(INTERFACE_NAME).call([this](){ this->onUpdated(); });
    }

    virtual void onUpdated() = 0;

public:
    sdbus::Struct<std::vector<sdbus::Struct<std::string, std::string, std::string>>, std::vector<sdbus::Struct<std::string, std::string, std::string, int32_t, std::vector<std::string>>>, std::vector<sdbus::Struct<std::string, std::vector<std::string>>>> getSettings()
    {
        sdbus::Struct<std::vector<sdbus::Struct<std::string, std::string, std::string>>, std::vector<sdbus::Struct<std::string, std::string, std::string, int32_t, std::vector<std::string>>>, std::vector<sdbus::Struct<std::string, std::vector<std::string>>>> result;
        m_proxy.callMethod("getSettings").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    void update(const sdbus::Struct<std::vector<sdbus::Struct<std::string, std::string, std::string>>, std::vector<sdbus::Struct<std::string, std::string, std::string, int32_t, std::vector<std::string>>>, std::vector<sdbus::Struct<std::string, std::vector<std::string>>>>& settings)
    {
        m_proxy.callMethod("update").onInterface(INTERFACE_NAME).withArguments(settings);
    }

    void addChain(const std::string& ipv, const std::string& table, const std::string& chain)
    {
        m_proxy.callMethod("addChain").onInterface(INTERFACE_NAME).withArguments(ipv, table, chain);
    }

    void removeChain(const std::string& ipv, const std::string& table, const std::string& chain)
    {
        m_proxy.callMethod("removeChain").onInterface(INTERFACE_NAME).withArguments(ipv, table, chain);
    }

    bool queryChain(const std::string& ipv, const std::string& table, const std::string& chain)
    {
        bool result;
        m_proxy.callMethod("queryChain").onInterface(INTERFACE_NAME).withArguments(ipv, table, chain).storeResultsTo(result);
        return result;
    }

    std::vector<std::string> getChains(const std::string& ipv, const std::string& table)
    {
        std::vector<std::string> result;
        m_proxy.callMethod("getChains").onInterface(INTERFACE_NAME).withArguments(ipv, table).storeResultsTo(result);
        return result;
    }

    std::vector<sdbus::Struct<std::string, std::string, std::string>> getAllChains()
    {
        std::vector<sdbus::Struct<std::string, std::string, std::string>> result;
        m_proxy.callMethod("getAllChains").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    void addRule(const std::string& ipv, const std::string& table, const std::string& chain, const int32_t& priority, const std::vector<std::string>& args)
    {
        m_proxy.callMethod("addRule").onInterface(INTERFACE_NAME).withArguments(ipv, table, chain, priority, args);
    }

    void removeRule(const std::string& ipv, const std::string& table, const std::string& chain, const int32_t& priority, const std::vector<std::string>& args)
    {
        m_proxy.callMethod("removeRule").onInterface(INTERFACE_NAME).withArguments(ipv, table, chain, priority, args);
    }

    bool queryRule(const std::string& ipv, const std::string& table, const std::string& chain, const int32_t& priority, const std::vector<std::string>& args)
    {
        bool result;
        m_proxy.callMethod("queryRule").onInterface(INTERFACE_NAME).withArguments(ipv, table, chain, priority, args).storeResultsTo(result);
        return result;
    }

    void removeRules(const std::string& ipv, const std::string& table, const std::string& chain)
    {
        m_proxy.callMethod("removeRules").onInterface(INTERFACE_NAME).withArguments(ipv, table, chain);
    }

    std::vector<sdbus::Struct<int32_t, std::vector<std::string>>> getRules(const std::string& ipv, const std::string& table, const std::string& chain)
    {
        std::vector<sdbus::Struct<int32_t, std::vector<std::string>>> result;
        m_proxy.callMethod("getRules").onInterface(INTERFACE_NAME).withArguments(ipv, table, chain).storeResultsTo(result);
        return result;
    }

    std::vector<sdbus::Struct<std::string, std::string, std::string, int32_t, std::vector<std::string>>> getAllRules()
    {
        std::vector<sdbus::Struct<std::string, std::string, std::string, int32_t, std::vector<std::string>>> result;
        m_proxy.callMethod("getAllRules").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

    void addPassthrough(const std::string& ipv, const std::vector<std::string>& args)
    {
        m_proxy.callMethod("addPassthrough").onInterface(INTERFACE_NAME).withArguments(ipv, args);
    }

    void removePassthrough(const std::string& ipv, const std::vector<std::string>& args)
    {
        m_proxy.callMethod("removePassthrough").onInterface(INTERFACE_NAME).withArguments(ipv, args);
    }

    bool queryPassthrough(const std::string& ipv, const std::vector<std::string>& args)
    {
        bool result;
        m_proxy.callMethod("queryPassthrough").onInterface(INTERFACE_NAME).withArguments(ipv, args).storeResultsTo(result);
        return result;
    }

    std::vector<std::vector<std::string>> getPassthroughs(const std::string& ipv)
    {
        std::vector<std::vector<std::string>> result;
        m_proxy.callMethod("getPassthroughs").onInterface(INTERFACE_NAME).withArguments(ipv).storeResultsTo(result);
        return result;
    }

    std::vector<sdbus::Struct<std::string, std::vector<std::string>>> getAllPassthroughs()
    {
        std::vector<sdbus::Struct<std::string, std::vector<std::string>>> result;
        m_proxy.callMethod("getAllPassthroughs").onInterface(INTERFACE_NAME).storeResultsTo(result);
        return result;
    }

private:
    sdbus::IProxy& m_proxy;
};

}}}} // namespaces

#endif
